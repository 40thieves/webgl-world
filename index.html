<!doctype html>
<html lang="en">
<head>
<title>A Simple WebGL Application</title>
<meta charset="utf-8">

<script src="lib/webgl-debug.js"></script>

<!-- Vertex shader (written in OpenGL ES Shading Language) -->
<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;

	void main() {
		gl_Position = vec4(aVertexPosition, 1.0);
	}
</script>

<!-- Fragment shader (written in OpenGL ES Shading Language) -->
<script id="shader-fs" type="x-shader/x-fragment">
	precision mediump float;

	void main() {
		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
	}
</script>

<!-- WebGL program -->
<script type="text/javascript">
var gl
,	canvas
,	shaderProgram

,	vertexPositionBuffer
,	vertexIndexBuffer
;

function startup() {
	canvas = document.getElementById('myGLCanvas');
	gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));

	setupShaders();
	setupBuffers();

	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	draw();
}

function createGLContext(canvas) {
	var names = ['webgl', 'experimental-webgl']
	,	context = null
	;

	for (var i = 0; i < names.length; i++) {
		try {
			context = canvas.getContext(names[i]);
		}
		catch(e) {

		}

		if (context) 
			break;
	}

	if (context) {
		context.viewportWidth = canvas.width;
		context.viewportHeight = canvas.height;
	}
	else {
		console.log('Failed to create WebGL context');
	}

	return context;
}

function loadShaderFromDOM(id) {
	var shaderScript = document.getElementById(id);

	if ( ! shaderScript)
		return null;

	var shaderSource = '';
	var currentChild = shaderScript.firstChild;

	while (currentChild) {
		if (currentChild.nodeType == 3) { // TEXT_NODE
			shaderSource += currentChild.textContent;
		}
		currentChild = currentChild.nextSibling;
	}

	var shader;
	if (shaderScript.type == 'x-shader/x-fragment') {
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	}
	else if (shaderScript.type == 'x-shader/x-vertex') {
		shader = gl.createShader(gl.VERTEX_SHADER);
	}
	else {
		return null;
	}

	gl.shaderSource(shader, shaderSource);
	gl.compileShader(shader);

	if ( ! gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		console.log('Shader not compiled');
		console.log(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}

function setupShaders() {
	vertexShader = loadShaderFromDOM('shader-vs');
	fragmentShader = loadShaderFromDOM('shader-fs');

	shaderProgram = gl.createProgram();

	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);

	gl.linkProgram(shaderProgram);
	if ( ! gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		console.log('Failed to set up shaders');
	}

	gl.useProgram(shaderProgram);

	shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
	gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
}

function setupBuffers() {
	vertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);

	vertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);

	var positionData = []
	,	indexData = []

	,	m = 30
	,	n = 30
	,	r = 2

	,	theta, sinTheta, cosTheta, phi, sinPhi,	cosTheta
	,	x, y, z
	,	v1, v2
	;

	for (i = 0; i <= m; i++) {
		theta = i * Math.PI / m;
		sinTheta = Math.sin(theta);
		cosTheta = Math.cos(theta);

		for (j = 0; j <= n; j++) {
			phi = j * 2 * Math.PI / n;
			sinPhi = Math.sin(phi);
			cosPhi = Math.cos(phi);

			x = cosPhi * sinTheta;
			y = cosTheta;
			z = sinPhi * sinTheta;

			positionData.push(r * x);
			positionData.push(r * y);
			positionData.push(r * z);
		}
	}

	for (var i = 0; i < m; i++) {
		for (var j = 0; j < n; j++) {
			v1 = (i * (n + 1)) + j;
			v2 = v1 + n + 1;
			v3 = v1 + 1;
			v4 = v2 + 1;

			// Indices of first triangle
			indexData.push(v1);
			indexData.push(v2);
			indexData.push(v3);

			// Indices of second triangle
			indexData.push(v3);
			indexData.push(v2);
			indexData.push(v4);
		}
	}

	// Loads vertex position buffer with data
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionData), gl.STATIC_DRAW);

	vertexPositionBuffer.itemSize = 3;
	vertexPositionBuffer.numberOfItems = positionData.length / 3;

	// Loads index buffer with data
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);

	vertexIndexBuffer.itemSize = 1;
	vertexIndexBuffer.numberOfItems = indexData.length;
}

function draw() {
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

	gl.clear(gl.COLOR_BUFFER_BIT);

	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
	gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
	gl.drawElements(gl.TRIANGLES, vertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
}

</script>

</head>
<body onload="startup()">
	<canvas id="myGLCanvas" width="500" height="500"></canvas>
</body>
</html>
