<!DOCTYPE html>
<html lang="en">
<head>
<title>WebGL Coursework</title>
<meta charset="utf-8">

<script type="text/javascript" src="lib/glMatrix.js"></script>
<script type="text/javascript" src="lib/webgl-utils.js"></script>
<script type="text/javascript" src="lib/webgl-debug.js"></script>

<!-- Vertex shader (written in OpenGL ES Shading Language) -->
<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoordinates;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;

	varying vec2 vTextureCoordinates;

	void main() {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoordinates = aTextureCoordinates;
	}
</script>

<!-- Fragment shader (written in Open ES Shading Language) -->
<script id="shader-fs" type="x-shader/x-fragment">
	precision mediump float;

	varying vec2 vTextureCoordinates;
	uniform sampler2D uSampler;

	void main() {
		gl_FragColor = texture2D(uSampler, vTextureCoordinates);
	}
</script>

<!-- WebGL Program -->
<script type="text/javascript">
var gl
,	pwgl = {}
,	canvas

,	mousedown = false
,	lastMouseX, lastMouseY = 0
,	transZ = 0
,	rotationMatrix = mat4.create()
;

mat4.identity(rotationMatrix);

pwgl.ongoingImageLoads = [];

function createGLContext(canvas) {
	var names = ['webgl', 'experimental-webgl']
	,	context = null
	;

	for (var i = 0; i < names.length; i++) {
		try {
			context = canvas.getContext(names[i]);
		}
		catch (e) {}

		if (context)
			break;
	}

	if (context) {
		context.viewportWidth = canvas.width;
		context.viewportHeight = canvas.height;
	}
	else {
		alert("Could not initialise WebGL, sorry :-(");
	}

	return context;
}

function loadShaderFromDOM(id) {
	var shaderScript = document.getElementById(id);

	if ( ! shaderScript)
		return null;

	var shaderSource = ''
	,	currentChild = shaderScript.firstChild
	;

	while (currentChild) {
		if (currentChild.nodeType == 3) { // Text node
			shaderSource += currentChild.textContent;
		}
		currentChild = currentChild.nextSibling;
	}

	var shader;
	if (shaderScript.type == 'x-shader/x-fragment') {
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	}
	else if (shaderScript.type == 'x-shader/x-vertex') {
		shader = gl.createShader(gl.VERTEX_SHADER);
	}
	else {
		return null;
	}

	gl.shaderSource(shader, shaderSource);
	gl.compileShader(shader);

	if ( ! gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}

function setUpShaders() {
	var vertexShader = loadShaderFromDOM('shader-vs')
	,	fragmentShader = loadShaderFromDOM('shader-fs')
	,	shaderProgram = gl.createProgram()
	;

	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);

	gl.linkProgram(shaderProgram);
	if ( ! gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		alert('Could not initialise shaders');
	}

	gl.useProgram(shaderProgram);

	pwgl.vertexPositionAttributeLoc = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
	pwgl.vertexTextureAttributeLoc = gl.getAttribLocation(shaderProgram, 'aTextureCoordinates');
	pwgl.uniformMVMatrixLoc = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
	pwgl.uniformProjMatrixLoc = gl.getUniformLocation(shaderProgram, 'uPMatrix');
	pwgl.uniformSamplerLoc = gl.getUniformLocation(shaderProgram, 'uSampler');

	gl.enableVertexAttribArray(pwgl.vertexPositionAttributeLoc);
	gl.enableVertexAttribArray(pwgl.vertexTextureAttributeLoc);

	pwgl.modelViewMatrix = mat4.create();
	pwgl.projectionMatrix = mat4.create();
	pwgl.modelViewMatrixStack = [];
}

function pushModelViewMatrix() {
	var copy = mat4.create(pwgl.modelViewMatrix);
	pwgl.modelViewMatrixStack.push(copy);
}

function popModelViewMatrix() {
	if (pwgl.modelViewMatrixStack.length == 0) {
		throw 'Error popModelViewMatrix() - Stack was empty';
	}
	pwgl.modelViewMatrix = pwgl.modelViewMatrixStack.pop();
}

function setUpBuffers() {
	setUpCubeBuffers();
	setUpSphereBuffers();
}

function setUpCubeBuffers() {
	var cubePositionData = []
	,	cubeIndexData = []
	,	cubeTextureCoordData = []
	;

	cubeTextureCoordData = [
		// Front face
		0.0, 0.0, //v0
		1.0, 0.0, //v1
		1.0, 1.0, //v2
		0.0, 1.0, //v3

		// Back face
		0.0, 1.0, //v4
		1.0, 1.0, //v5
		1.0, 0.0, //v6
		0.0, 0.0, //v7

		// Left face
		0.0, 1.0, //v1
		1.0, 1.0, //v5
		1.0, 0.0, //v6
		0.0, 0.0, //v2

		// Right face
		0.0, 1.0, //v0
		1.0, 1.0, //v3
		1.0, 0.0, //v7
		0.0, 0.0, //v4

		// Top face
		0.0, 1.0, //v0
		1.0, 1.0, //v4
		1.0, 0.0, //v5
		0.0, 0.0, //v1

		// Bottom face
		0.0, 1.0, //v3
		1.0, 1.0, //v7
		1.0, 0.0, //v6
		0.0, 0.0, //v2
	];

	cubePositionData = [
		 1.0,  1.0,  1.0, //v0
		-1.0,  1.0,  1.0, //v1
		-1.0, -1.0,  1.0, //v2
		 1.0, -1.0,  1.0, //v3
		 1.0,  1.0, -1.0, //v4
		-1.0,  1.0, -1.0, //v5
		-1.0, -1.0, -1.0, //v6
		 1.0, -1.0, -1.0, //v7
	];

	cubeIndexData = [
		0, 1, 2,	0, 2, 3,	// Front face
		4, 6, 5,	4, 7, 6,	// Back face
		1, 5, 6,	1, 6, 2,	// Left
		0, 3, 7,	0, 7, 4,	// Right
		0, 5, 1,	0, 4, 5,	// Top
		3, 2, 6,	3, 6, 7 	// Bottom
	];

	// Creates texture buffer & loads texture data
	pwgl.cubeVertexTextureCoordinateBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.cubeVertexTextureCoordinateBuffer);

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeTextureCoordData), gl.STATIC_DRAW);

	pwgl.CUBE_VERTEX_TEX_COORD_BUFF_ITEM_SIZE = 2;
	pwgl.CUBE_VERTEX_TEX_COORD_BUFF_NUM_ITEMS = cubeTextureCoordData.length / 2;

	// Creates position buffer & loads position data
	pwgl.cubeVertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.cubeVertexPositionBuffer);

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubePositionData), gl.STATIC_DRAW);

	pwgl.CUBE_VERTEX_POS_BUFF_ITEM_SIZE = 3;
	pwgl.CUBE_VERTEX_POS_BUFF_NUM_ITEMS = cubePositionData.length / 3;

	// Creates index buffer & loads index data
	pwgl.cubeVertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.cubeVertexIndexBuffer);

	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeIndexData), gl.STATIC_DRAW);

	pwgl.CUBE_VERTEX_INDEX_BUFF_ITEM_SIZE = 1;
	pwgl.CUBE_VERTEX_INDEX_BUFF_NUM_ITEMS = cubeIndexData.length;
}

function setUpSphereBuffers() {
	var spherePositionData = []
	,	sphereIndexData = []
	,	sphereTextureCoordData = []

	,	m = 30
	,	n = 30
	,	r = 2

	,	theta, sinTheta, cosTheta, phi, sinPhi, cosPhi
	,	x, y, z
	,	u, v
	,	v1, v2
	;

	for (var i = 0; i <= m; i++) {
		theta = i * Math.PI / m;
		sinTheta = Math.sin(theta);
		cosTheta = Math.cos(theta);

		for (var j = 0; j <= n; j++) {
			phi = j * 2 * Math.PI / n;
			sinPhi = Math.sin(phi);
			cosPhi = Math.cos(phi);

			x = cosPhi * sinTheta;
			y = cosTheta;
			z = sinPhi * sinTheta;

			u = 1 - (j / n);
			v = 1 - (i / m);

			sphereTextureCoordData.push(u);
			sphereTextureCoordData.push(v);

			spherePositionData.push(r * x);
			spherePositionData.push(r * y);
			spherePositionData.push(r * z);
		}
	}

	for (var i = 0; i < m; i++) {
		for (var j = 0; j < n; j++) {
			v1 = (i * (n + 1)) + j;
			v2 = v1 + n + 1;

			// Indices of first triangle
			sphereIndexData.push(v1);
			sphereIndexData.push(v2);
			sphereIndexData.push(v1 + 1);

			// Indices of second triangle
			sphereIndexData.push(v2);
			sphereIndexData.push(v2 + 1);
			sphereIndexData.push(v1 + 1);
		}
	}

	// Creates texture buffer & loads texture data
	pwgl.sphereVertexTextureCoordinateBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphereVertexTextureCoordinateBuffer);

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereTextureCoordData), gl.STATIC_DRAW);

	pwgl.SPHERE_VERTEX_TEX_COORD_BUFF_ITEM_SIZE = 2;
	pwgl.SPHERE_VERTEX_TEX_COORD_BUFF_NUM_ITEMS = sphereTextureCoordData.length / 2;

	// Creates position buffer & loads position data
	pwgl.sphereVertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphereVertexPositionBuffer);

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(spherePositionData), gl.STATIC_DRAW);

	pwgl.SPHERE_VERTEX_POS_BUFF_ITEM_SIZE = 3;
	pwgl.SPHERE_VERTEX_POS_BUFF_NUM_ITEMS = spherePositionData.length / 3;

	// Creates index buffer & loads index data
	pwgl.sphereVertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.sphereVertexIndexBuffer);

	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereIndexData), gl.STATIC_DRAW);

	pwgl.SPHERE_VERTEX_INDEX_BUFF_ITEM_SIZE = 1;
	pwgl.SPHERE_VERTEX_INDEX_BUFF_NUM_ITEMS = sphereIndexData.length;
}

function setUpTextures() {
	// Earth texture
	pwgl.earthTexture = gl.createTexture();
	loadImageForTexture('assets/earth.jpg', pwgl.earthTexture);

	pwgl.crateTexture = gl.createTexture();
	loadImageForTexture('assets/crate.gif', pwgl.crateTexture);
}

function loadImageForTexture(url, texture) {
	var image = new Image();

	// Sets up callback for when image has finished downloading
	image.onload = function() {
		// Removes current image out of ongoingImageLoads array
		pwgl.ongoingImageLoads.splice(pwgl.ongoingImageLoads.indexOf(image), 1);

		textureFinishedLoading(image, texture);
	}

	pwgl.ongoingImageLoads.push(image);
	image.src = url;
}

function textureFinishedLoading(image, texture) {
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Flips image to use WebGL axis, instead of DOM axis
	gl.bindTexture(gl.TEXTURE_2D, texture);

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Image loaded, texture area 0
	gl.generateMipmap(gl.TEXTURE_2D); // Generates mipmap levels

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);

	gl.bindTexture(gl.TEXTURE_2D, null);
}

function degToRad(degrees) {
	return degrees * Math.PI / 180;
}

function pushModelViewMatrix() {
	var cache = mat4.create(pwgl.modelViewMatrix);
	pwgl.modelViewMatrixStack.push(cache);
}

function popModelViewMatrix() {
	if (pwgl.modelViewMatrixStack.length == 0) {
		throw 'Error - ModelView Stack empty';
	}
	pwgl.modelViewMatrix = pwgl.modelViewMatrixStack.pop();
}

function uploadModelViewMatrixToShader() {
	gl.uniformMatrix4fv(pwgl.uniformMVMatrixLoc, false, pwgl.modelViewMatrix);
}

function uploadProjectionMatrixToShader() {
	gl.uniformMatrix4fv(pwgl.uniformProjMatrixLoc, false, pwgl.projectionMatrix);
}

function drawCube() {
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, pwgl.crateTexture);
	gl.uniform1i(pwgl.uniformSamplerLoc, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.cubeVertexPositionBuffer);
	gl.vertexAttribPointer(pwgl.vertexPositionAttributeLoc, pwgl.CUBE_VERTEX_POS_BUFF_ITEM_SIZE, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.cubeVertexTextureCoordinateBuffer);
	gl.vertexAttribPointer(pwgl.vertexTextureAttributeLoc, pwgl.CUBE_VERTEX_TEX_COORD_BUFF_ITEM_SIZE, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.cubeVertexIndexBuffer);

	gl.drawElements(gl.TRIANGLES, pwgl.CUBE_VERTEX_INDEX_BUFF_NUM_ITEMS, gl.UNSIGNED_SHORT, 0);
}

function drawSphere() {
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, pwgl.earthTexture);
	gl.uniform1i(pwgl.uniformSamplerLoc, 0);

	// Draw sphere
	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphereVertexPositionBuffer);
	gl.vertexAttribPointer(pwgl.vertexPositionAttributeLoc, pwgl.SPHERE_VERTEX_POS_BUFF_ITEM_SIZE, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.sphereVertexTextureCoordinateBuffer);
	gl.vertexAttribPointer(pwgl.vertexTextureAttributeLoc, pwgl.SPHERE_VERTEX_TEX_COORD_BUFF_ITEM_SIZE, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.sphereVertexIndexBuffer);

	gl.drawElements(gl.TRIANGLES, pwgl.SPHERE_VERTEX_INDEX_BUFF_NUM_ITEMS, gl.UNSIGNED_SHORT, 0);
}

function draw() {
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pwgl.projectionMatrix);
	mat4.identity(pwgl.modelViewMatrix);
	mat4.lookAt([0, 0, -8], [0, 0, 0], [0, 1, 0], pwgl.modelViewMatrix);

	uploadProjectionMatrixToShader();
	uploadModelViewMatrixToShader();

	mat4.translate(pwgl.modelViewMatrix, [0, 0, transZ], pwgl.modelViewMatrix); // Translation for zoom
	mat4.multiply(pwgl.modelViewMatrix, rotationMatrix); // Translation for rotation

	// Draw cube
	pushModelViewMatrix();

	mat4.translate(pwgl.modelViewMatrix, [-2.5, 0, 0], pwgl.modelViewMatrix);
	mat4.scale(pwgl.modelViewMatrix, [0.1, 0.1, 0.1], pwgl.modelViewMatrix);

	uploadModelViewMatrixToShader();

	drawCube();

	popModelViewMatrix();

	// Draw sphere
	pushModelViewMatrix();

	uploadModelViewMatrixToShader();

	drawSphere();

	popModelViewMatrix();

	pwgl.requestId = requestAnimFrame(draw, canvas);
}

function startup() {
	canvas = document.getElementById('myGLCanvas');
	canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas);

	// WebGL event handlers
	canvas.addEventListener('webglcontextlost', handleContextLost, false);
	canvas.addEventListener('webglcontextrestored', handleContextRestored, false);

	// Mouse event handlers
	canvas.addEventListener('mousedown', handleMouseDown, false);
	canvas.addEventListener('mouseup', handleMouseUp, false);
	canvas.addEventListener('mousemove', handleMouseMove, false);
	canvas.addEventListener('wheel', handleMouseWheel, false); // Many handlers for scroll, different browsers
	canvas.addEventListener('mousewheel', handleMouseWheel, false);
	canvas.addEventListener('DOMMouseScroll', handleMouseWheel, false);

	gl = createGLContext(canvas);

	setUpShaders();
	setUpBuffers();
	setUpTextures();

	gl.clearColor(1.0, 1.0, 1.0, 1.0);
	gl.enable(gl.DEPTH_TEST);

	draw();
}

function handleContextLost(e) {
	e.preventDefault();
	cancelRequestAnimFrame(pwgl.requestId);

	// Ignore all ongoing image loads by removing their onload handler
	for (var i = 0; i < pwgl.ongoingImageLoads.length; i++) {
		pwgl.ongoingImageLoads[i].onload = undefined;
	}
	pwgl.ongoingImageLoads = [];
}

function handleContextRestored(e) {
	setUpShaders();
	setUpBuffers();
	setUpTextures();

	pwgl.requestId = requestAnimFrame(draw, canvas);
}

function handleMouseDown(e) {
	mousedown = true;
	lastMouseX = e.clientX;
	lastMouseY = e.clientY;
}

function handleMouseUp(e) {
	mousedown = false;
}

function handleMouseWheel(e) {
	e.preventDefault();

	// Webkit uses wheelDelta
	if (e.wheelDelta) {
		transZ -= 1 / 120 * e.wheelDelta;
	}
	// Other browers use detail
	else {
		transZ -= -e.deltaY;
	}

	// // Prevent zooming too far in, through model
	// if (transZ < -3)
	// 	transZ = -3;

	// // Prevent zooming too far out, so model is out of view frustrum
	// if (transZ > 94)
	// 	transZ = 94;
}

function handleMouseMove(e) {
	// Return if not dragging
	if ( ! mousedown)
		return;

	var newMouseX = e.clientX
	,	newMouseY = e.clientY

	// Calculate distance travelled by mouse during drag
	,	deltaX = newMouseX - lastMouseX
	,	deltaY = newMouseY - lastMouseY
	;

	// Calculate rotation matrices
	mat4.rotate(rotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
	mat4.rotate(rotationMatrix, -degToRad(deltaY / 10), [1, 0, 0]);

	lastMouseX = newMouseX;
	lastMouseY = newMouseY;
}
</script>

</head>
<body onload="startup()">
	<canvas id="myGLCanvas" width="500" height="500"></canvas>
</body>
</html>
